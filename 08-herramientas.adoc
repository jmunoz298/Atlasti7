[[herramientas-de-exploracion]]
== Herramientas de exploración

En este capítulo describiremos algunas de las herramientas que podemos utilizar para explorar nuestra UH en busca de informaciones concretas. En primer lugar mostraremos la herramienta “simple” de búsqueda de texto en documentos, a continuación la forma de buscar texto en el conjunto de componentes de la UH (__Examinador de objetos__). Veremos también cómo podemos explorar el conjunto de objetos de la UH (__Bosque de códigos__ y __Explorador de UH__). Dedicaremos también un amplio espacio a describir la _Herramienta de consulta_ que nos permite recuperar citas que cumplen determinadas condiciones de codificación. Dedicaremos otro apartado a las herramientas de exploración de concurrencias (__Árbol de concurrencias__ y __Tabla de concurrencias__). Para finalizar, veremos cómo podemos depurar posibles codificaciones redundantes (__Analizador de codificaciones__).

[[buscar-texto]]
=== Buscar texto

En el apartado dedicado a la <<autocodificacion, autocodificación>>, hemos visto que ésta implicaba realizar una búsqueda de texto, y avanzábamos que esta función de ATLAS.ti va mucho más allá de las posibilidades a las que estamos acostumbrados habitualmente en los procesadores de texto. Tres son las características principales del sistema de búsqueda:

1.  La búsqueda abarca el conjunto de documentos que componen la UH, y no únicamente el documento activo.
2.  Pueden realizarse búsquedas de varios términos de forma simultánea.
3.  Pueden utilizarse las sofisticadas opciones de la búsqueda con “expresiones regulares”.

Respecto a la primera característica no hay demasiado que comentar, por lo que después de describir de forma general la herramienta, explicaremos las características de las otras dos.

Activamos la herramienta con la opción `Edición > Buscar` o con el icono lupa de la barra de herramientas de documentos (vertical).

La ventana que aparece tiene las siguientes secciones:

[[img-ventana-herramientas-busqueda, Ventana de herramienta de búsqueda]]
.Ventana de herramienta de búsqueda
image::image-131.png[{alt="Ventana de herramienta de búsqueda", align="center"]

.  Espacio para escritura (y almacenamiento) de la expresión de búsqueda.
.  Botones para ejecutar la búsqueda hacia adelante o hacia atrás.
.  Activar/desactivar la discriminación de mayúsculas/minúsculas en la búsqueda.
.  Activar/desactivar la modalidad de búsqueda GREP.footnote:[Acrónimo de “Global find Regular Expressions and Print”] (expresiones regulares).
.  Opciones de la búsqueda por categorías.
.  Barra de estatus. Indica el tipo de búsqueda activo.

[[busqueda-simple]]
==== Búsqueda simple

Para realizar una búsqueda simple, lo único que tenemos que hacer es introducir en (1) la expresión de búsqueda,footnote:[Podemos utilizar el carácter especial “*” para indicar “cualquier carácter o caracteres. Si el asterisco va a continuación de la sentencia sería equivalente a indicar “todos los caracteres a continuación”, si la precede, el significado sería “todos los caracteres anteriores”.] decidir si queremos que la búsqueda diferencie entre mayúsculas y minúsculas (3) y hacer clic en (2) para ejecutar la búsqueda hacia adelante o hacia atrás. Una vez que se haya realizado la búsqueda en el documento activo, el programa nos preguntará si queremos continuarla en el resto de documentos de la UH (figura <<img-continuar-busqueda>>). Si contestamos que sí, se realizará la búsqueda en el resto de documentos, sin volver a pedirnos confirmación.

WARNING: Hay que tener en cuenta, que la búsqueda se habrá completado una vez que se haya realizado en el último documento de la UH, por lo que si hemos dado la orden de inicio de la búsqueda estando activo el documento P3, al llegar al último documento la búsqueda no continuará en los documentos P1 y P2.

[[img-continuar-busqueda, Continuar búsqueda]]
.Continuar búsqueda
image::image-132.png[{alt="Continuar búsqueda", align="center"]

[[busqueda-por-categorias]]
==== Búsqueda por categorías

La búsqueda por categorías implica la definición, en la sentencia de búsqueda, de un conjunto de términos diferentes que se buscarán de forma simultánea. Por lo tanto, podemos realizar búsquedas de un término cuya formulación concreta pueda variar en el texto (por ejemplo un término y sus sinónimos) o de conjuntos de términos que compartan alguna característica (para poner un ejemplo muy simple, podríamos buscar la aparición de “todos los artículos determinados” especificando en la búsqueda “el”, “la”, “los” y “las”).

En nuestro caso, podría interesarnos buscar todas las referencias que hacen los parlamentarios a terceros países, por lo que podríamos definir una búsqueda en la que se incluyeran Francia, Alemania, Inglaterra… de forma que la búsqueda fuera exitosa con la aparición de cualquiera de ellos en el texto.

Para ello, introduciremos en la zona de búsqueda los nombres de los diferentes países separados por una barra vertical `|, por ejemplo:

`Francia|Alemania|Inglaterra`

TIP:: En la mayoría de los teclados, para introducimos este signo con la combinación de teclas `AltGr+1` (aunque este último carácter puede variar en función del teclado).

Si cerramos la ventana de búsqueda y volvemos a abrirla, observaremos que sigue apareciendo la última sentencia de búsqueda que habíamos realizado, pero precedida por los caracteres `TEMP:=`

`TEMP:=Francia|Alemania|Inglaterra`

Si clicamos sobre la flecha ubicada a la derecha de la zona de escritura de la búsqueda, veremos además que, junto a esta, nos aparecen toda otra serie de búsquedas (predefinidas), todas ellas precedidas por algún término y los caracteres `:=` (dos puntos y signo de igualdad). Estos caracteres son los que utilizamos para definir auténticas categorías de búsqueda, es decir, para definir un identificador para las búsquedas. Dado que no lo habíamos hecho previamente, el programa ha identificado nuestra búsqueda como “TEMP”, pero podemos cambiar esa etiqueta por otra más significativa, como por ejemplo "EUROPA".footnote:[Si no cambiamos la etiqueta de la categoría, al realizar una nueva búsqueda, la anterior desaparecería de la lista, puesto que la nueva quedaría identificada igualmente como “TEMP”.] De esta forma, nuestra sentencia de búsqueda sería

`EUROPA:=Francia|Alemania|Inglaterra`

A continuación, podríamos crear otra categoría en la que incluyéramos a países americanos, por ejemplo

`AMERICA:=Estados Unidos|Canadá|México|Argentina`

Con la primera categoría encontraremos referencias a países europeos, con la segunda, referencias a países americanos, pero ¿y si queremos realizar una búsqueda en la que se incluyan tanto países europeos como americanos? Evidentemente una posibilidad sería crear una categoría en la que se incluyan todos los países de las categorías anteriores, pero dado que ya tenemos las categorías “EUROPA” y “AMÉRICA”, podemos hacer una búsqueda en la que la sentencia incluya a ambas categorías. Para ello, podríamos escribir lo siguiente.

`PAISES:=$EUROPA|$AMERICA`

Como podemos observar, la que hemos hecho ha sido preceder el nombre de las categorías con el signo `$`, y por lo tanto el significado de la búsqueda sería “Busca todos los elementos incluidos en la categoría EUROPA y en la categoría AMERICA”.

De la misma forma que buscamos países, podría interesarnos hacer búsquedas para encontrar referencias a políticos de determinados partidos. En este caso podríamos proceder a crear categorías para los diferentes partidos:

`BNG:=Jorquera|Pérez-Bouza`

`CC:=Oramas|Quintero`

A continuación podríamos crear nuevas categorías para agrupar a los partidos en función de su ámbito terrirorial:

`AUTONOMICO:= $AMAIUR|$BNG|$CiU|$PNV|$ICV|$UPN`

Y por último una categoría que englobara a todos los partidos (y por lo tanto a todos los políticos).

`POLITICOS:=$AUTONOMICO|$ESTATAL`

Hay que tener en cuenta que una vez que cerremos la sesión con Atlas, desaparecerán las categorías así definidas. Para poder utilizarlas durante más de una sesión hay que archivarlas mediante la opción __Guardar Categorías__, a la que podemos acceder con el botón _Opciones_ de la ventana de búsqueda. Atlas pedirá un nombre de archivo con el que salvar la lista, y sugerirá como nombre por defecto “SEARCHBIB.SKT”.

[[img-opciones-busqueda, Opciones de búsqueda]]
.Opciones de búsqueda
image::image-135.png[{alt="Opciones de búsqueda", align="center"]

Podemos sobreescribir ese archivo o dar un nombre diferente, teniendo en cuenta que si lo sobreescribimos, la lista que acabamos de salvar será la que utilizará ATLAS.ti por defecto la próxima vez que utilicemos el programa. En el caso de dar un nombre de archivo diferente, para poder recuperar esa lista en futuras sesiones, tendremos que utilizar la opción __Cargar Categorías__. También podemos eliminar elementos de la lista de categorías con la opción __Borrar Categoría.__footnote:[Otra forma de modificar la lista de categorías es modificar directamente el fichero Srchbib.skt(o crear otro fichero .skt) con un editor de texto.]

[[busqueda-grep]]
==== Búsqueda GREP

Si la búsqueda por categorías permite la realización de búsquedas sofisticadas, la opción GREP aumenta todavía más las posibilidades de las mismas gracias a la posibilidad de la utilización de __expresiones regulares__.

Esta modalidad de búsqueda, implica utilizar caracteres “comodín” junto al texto de búsqueda, de una forma similar a la utilización del _comodín_ `*` (asterisco) en las búsquedas simples, pero permitiendo en este caso muchas más posibilidades que el “simple” “todo lo que venga a continuación”.

Aunque es muy probable que no necesitemos toda la potencia de la búsqueda GREP, no está de más saber de su existencia para poder consultar los operadores en el caso en que necesitemos una búsqueda especial. En la siguiente tabla ofrecemos el listado de los operadores que hemos comprobado que funcionan en ATLAS.ti, y a continuación ilustraremos su utilización con algunos ejemplos.

[[tab-operadores-grep, Operadores GREP]]
.Operadores GREP
[.center, cols="30%,70%",options="header",]
|=======================================================================
|Operador |Función
|^__término__ |Limita la expresión de búsqueda que sigue al marcador al
principio de la línea. Si se utiliza como el primer carácter dentro de
una expresión entre paréntesis, excluye de la búsqueda el rango
especificado.

|__término__$|Limita la expresión de búsqueda precedente al final de la
línea.

|\<__término__ |Limita la expresión de búsqueda siguiente al inicio de
una palabra.

|__término__\> |Limita la expresión de búsqueda precedente al inicio
de una palabra

| \B__término__ |Limita la expresión de búsqueda siguiente a NO inicio de palabra

| __término__B\ |Limita la expresión de búsqueda precedente a NO final de palabra

|. |Localiza cualquier carácter.

| \w |Localiza cualquier carácter alfanumérico.

|* |Localiza cualquier cantidad (o su ausencia) de la expresión
precedente.

|+ |Localiza al menos una ocurrencia de la expresión precedente.

|? |Localiza cero o una ocurrencia de la expresión precedente.

|[__carácter1____carácter2__ ] |Localiza un conjunto de caracteres.

|[__carácter1__-__carácter2__ ] |Localiza un rango de caracteres.

|(_término_ \| _término_ \| _término_) |Localiza varios términos de forma simultánea.

|[^_término_] |Niega el término siguiente (localiza la no ocurrencia)]

|:d |Localiza cualquier dígito.

| \ |Carácter utilizado cuando en la expresión se debe incluir uno de los
caracteres especiales anteriores.
|=======================================================================

*Búsqueda al inicio de línea*

Anteriormente hemos realizado la autocodificación de las intervenciones de los participantes utilizando como criterio de búsqueda la etiqueta de participante. Comentábamos que para que el resultado sea correcto, el formato de las etiquetas debía ser lo suficientemente exclusivo como para no poder confundirse con el mismo texto apareciendo en otra parte del documento sin ser etiqueta de participante. Por ejemplo, si queremos autocodificar las intervenciones del Presidente, la etiqueta “Presidente” no sería válida, puesto que podemos encontrar la misma palabra en momentos en que otros participantes aludan al presidente. En nuestro caso esto no ocurre, puesto que la etiqueta de participante es “Presidente.-”, es decir, incluye los caracteres `.-` lo que hace altamente improbable que ese texto exacto esté presente en otras partes del documento.

¿Pero qué pasaría si nuestras etiquetas no cumplen esa característica? Evidentemente, si no hemos realizado previamente ningún trabajo de segmentación/codificación sobre el documento, la mejor alternativa es volver al archivo original para modificar las etiquetas y volver a realizar la asignación del documento. En caso contrario, podemos optar por una opción (quizás no óptima) consistente en considerar que la aparición del término “Presidente” al inicio de un párrafo probablemente será la etiqueta del participante. Por lo tanto, nuestra búsqueda GREP debería ser `^Presidente`.

Si nuestros datos son entrevistas en las que han participado diferentes entrevistadores a los que hemos identificado etiquetas del tipo “Ent1:”, “Ent2:”, etc., y queremos autocodificar sus intervenciones de una forma genérica, con un único código “Entrevistador”, podemos utilizar otra combinación de expresiones.

Volveremos a utilizar el operador `^` seguido de “Ent” para especificar que la búsqueda sea al inicio de línea, y para que la búsqueda incluya el número de entrevistador utilizaremos el operador `:d`, es decir “cualquier carácter numérico”. Finalmente podemos incluir también el carácter `:` que forma parte del identificador de entrevistador, con lo que el resultado sería `^Ent:d:`. Es decir, “localiza, al inicio de la línea, todas las ocurrencias de 'Ent1:, Ent2: Ent3:...”

*Búsqueda al inicio de palabra*

Otra posibilidad que tenemos es hacer búsquedas que funciones únicamente cuando el texto buscado se encuentra al inicio (o al final) de una palabra pero no si se encuentra en cualquier otra posición.

Imaginemos, por ejemplo, que queremos encontrar palabras que empiecen por "pre". Si hacemos una búsqueda normal (no GREP), obtendríamos como resultado tanto “presidente”, "precisión" y "presente" como "imprecisión", "impresionante" o "comprensión", en las que el término de búsqueda forma parte de la palabra aunque no al inicio.

Una forma de hacer esta búsqueda utilizando GREP es mediante el operador `\<__término__` (o también `\b__término__`) de forma que la búsqueda sólo dará resultados si la ocurrencia es al inicio del término buscado

`\<pre`

`\bpre`

Si lo que queremos es lo contrario, que la búsqueda sólo de resultado cuando el término aparece al final de palabra, podemos utilizar:

`__término__\>`

(o `__término__\b`)

Así, si queremos encontrar palabra que acaben con "er" podríamos escribir cualquiera de las siguientes expresiones.

`er\>` o `er\b`

*Búsqueda de palabras completas*

La búsqueda anterior sólo identificará la cadena exacta "er" (al final de palabra), es decir, encontraría “er” en la palabra “conceder”, pero el texto seleccionado sería sólo “er”, no la palabra completa.

conced**er**

Si queremos que identifique palabras completas acabadas en “er” podemos ayudarnos de otros dos operadores GREP

`\w`= Cualquier carácter alfanumérico

`*` = Una o más veces el carácter anterior

Una búsqueda con la combinación de estos dos operadores encontraría cualquier palabra completa, puesto que el significado de la expresión sería “busca la aparición de cualquier cantidad (asterisco) de
caracteres alfanuméricos (`\w`)”.

Si a continuación añadimos `er\>`, estaremos ampliando nuestra expresión para que identifique únicamente las palabras “acabados en 'er'”

`\w*er\>`

Para finalizar, podemos unir los operadores "inicio de palabra" y "fin de palabra" para encontrar palabras completas con un determinado inicio y un determinado final. Por ejemplo, la expresión

`\<p\w*a\>`

encontrará cualquier palabra que empiece con "p" y acabe con "a", puesto que:

`\<p` es sinónimo de "palabra que empiece con la letra p"

`\w*` es sinónimo de "cualquier carácter alfanumérico (`\w`) de cualquier longitud (`*`)"

`a\>` es sinónimo de "palabra que termine con "a"

*Búsqueda de varios términos de forma simultánea*

Ya que estamos buscando finales de palabra y hemos puesto como ejemplo la cadena "er" podríamos hacer una búsqueda de todas las palabras que terminan en "ar", "er" o "ir" con la siguiente expresión

`(ar|er|ir)`

en la que utilizamos el paréntesis para agrupar el conjunto de caracteres a los que se aplicará la función "final de palabra" y la barra vertical para indicar las diferentes búsquedas a las que debe aplicarse. En este caso, de nuevo, el resultado de la búsqueda será únicamente las cadenas "ar", "er" o "ir", por lo que si lo que queremos son palabras completas con esas finalizaciones sólo tenemos que utilizar de forma conjunta las dos expresiones anteriores

`\w*(ar|er|ir)\>`

Volviendo a la autocodificación de nuestros participantes, recordamos que la estrategia que habíamos utilizado era crear un código para cada uno de ellos, es decir, cada uno de los parlamentarios está asociado con un código. Aunque esta estrategia es correcta, podríamos haber decidido que no nos interesa qué persona en concreto es la que está interviniendo sino el partido político al que pertenece.footnote:[Lo que en nuestro caso habíamos hecho creando familias de participantes para cada uno de los partidos políticos.] Esto significa que si queremos autocodificar las intervenciones de Josep Antoni Durán i Lleida, Pere Macias, Josep Sánchez i Llibre y Jordi Vilajoana, con el código “CiU” (en vez de un código diferente para cada uno de ellos). La expresión en este caso sería

`^Sr. (Duran|Macias|Sanchez|Vilajoana).-`

El problema de la expresión precedente es que no identificaría los “Sra” cuando interviene una política, por lo que podemos añadir un operador más

`^Sra?. (Buenaventura|Erkoreka)`

Dado que el operador `?` significa “localiza cero o ninguna ocurrencia de la expresión precedente”, encontraría tanto “Sr” como “Sra”, pues `a?` implica que puede aparecer o no el carácter “a”.

*Búsqueda en el “interior” de una palabra*

Ahora ya sabemos encontrar palabras cuyo inicio o final sea uno o varios caracteres determinados, pero también podríamos querer buscar palabras que contengan unos determinados caracteres (pero no empiecen o terminen por).

En este caso, el comando GREP que utilizaremos será

`\BTérmino`

De forma que si introducimos la siguiente expresión

`\Bdo`

El resultado será todas las palabras que contengan (pero no comiencen) por "do", por ejemplo, encontrará "adocenar" pero no "doce". De todas formas, también encontraría aquellas cuya finalización sea "do", por ejemplo "cogido". Si queremos evitar esto, es decir, encontrar aquellas en las que la cadena se encuentre únicamente en el "interior" de una palabra, entonces la expresión que deberemos utilizar será

`\Bdo\B`

*Búsqueda de texto entre comillas*

Si en una revisión bibliográfica queremos identificar todas las citas textuales, podemos realizar la siguiente búsqueda para encontrar todo el texto entrecomillado.

`"[^"]*"`

Es decir, buscamos `"` seguidas de cualquier cadena de caracteres (de cualquier longitud) que no sean comillas `[^"]*` y nuevamente `"`.

Evidentemente, tenemos que tener en cuenta el tipo de comillas utilizadas en el texto, por lo que si se trata de comillas tipográficas habrá que poner el carácter equivalente en la condición de búsqueda, o incluso combinar diferentes tipos de comillas en una única búsqueda, con la sintaxis `[ | ]`


[[busqueda-ampliada-examinador-de-objetos]]
=== Búsqueda ampliada: Examinador de objetos

Como hemos visto, la herramienta de búsqueda se limita a búsquedas de texto en los DPs, pero podríamos necesitar realizar búsquedas más amplias que incluyan otros componentes de nuestra UH. Por ejemplo, podríamos necesitar realizar una búsqueda de texto en los comentarios de los objetos (citas, códigos...) o en los memos. En ese caso podemos utilizar la herramienta __Examinador de objetos__, que nos permitirá ampliar la búsqueda a cualquier contenido textual de la Unidad Hermenéutica. Estas búsquedas, además, podrán realizarse utilizando tanto la opción de “búsqueda por categorías” como la de “búsqueda GREP” descritas previamente.

Al activar la herramienta con la opción `Herramientas > Examinador de objetos`, nos aparecerá la ventana _Examinador de objetos_, que en la práctica está compuesta por tres secciones, puesto que son tres los pasos de la búsqueda.

[[img-examinador-objetos-definicion, Examinador de objetos: Definición de búsqueda]]
.Examinador de objetos: Definición de búsqueda
image::image-136.png[{alt="Examinador de objetos: Definición de búsqueda", align="center"]

En primer lugar (1) definiremos la sentencia de búsqueda, para a continuación seleccionar los objetos a los que se aplicará la misma (2). Finalmente, en (3) podremos ver los resultados.

En la sección __Definir consulta__, definiremos la búsqueda a realizar (4) y si queremos o no utilizar la sintaxis GREP (5).footnote:[Podemos utilizar también la búsqueda por categorías.] Finalmente seleccionaremos (6) el ámbito al que se aplicará la búsqueda, es decir, en qué secciones de los diversos componentes (nombre del componente, comentario...).

En el ejemplo de la figura <<img-examinador-objetos-definicion>> estamos realizando una búsqueda utilizando sintaxis GREP. En este caso, una búsqueda de las apariciones de diferentes modalidades de referencia a “falsedad”. Si hemos leído el apartado dedicado a la búsqueda GREP podemos traducir la expresión de búsqueda como “busca las apariciones de “fals” seguidas de cualquiera otros caracteres (utilizando la expresión GREP `*.`) Por lo tanto, el resultado debería incluir términos como “falso”, “falsedad”, “falsos”, etc.

La segunda sección del _Examinador de objetos_ (_Selección de objetos_) nos permite seleccionar los objetos (componentes) a los que se aplicará la búsqueda.footnote:[_Unidad Hermenéutica_ hace referencia al comentario de la __Unidad Hermenéutica__.] Por lo tanto, si en la pantalla anterior hubiéramos seleccionado únicamente _Comentario_ como ámbito de búsqueda y en esta otra seleccionamos todos los objetos, la búsqueda se realizaría únicamente en los comentarios de todos los objetos de la UH. Si el término apareciera por ejemplo en una cita (pero no en un comentario de cita), la búsqueda no lo incluiría.

[[img-examinador-objetos-seleccion, Examinador de objetos: Selección de objetos]]
.Examinador de objetos: Selección de objetos
image::image-137.png[{alt="Examinador de objetos: Selección de objetos", align="center"]

La última sección de la herramienta nos muestra finalmente los resultados de la búsqueda. Como podemos ver en la figura siguiente, la búsqueda ha dado como resultado 12 coincidencias, que incluyen anotaciones, códigos, documentos y citas. En la misma ilustración podemos ver cómo, al seleccionar uno de los resultados, en la parte inferior de la ventana podemos ver el contexto en el que se encuentra. En este caso, la palabra “falsedad” aparece en el memo __Mentira__.

[[img-examinador-objetos-resultados, Examinador de objetos: Resultados]]
.Examinador de objetos: Resultados
image::image-138.png[{alt="Examinador de objetos: Resultados", align="center"]

[[exploracion-de-objetos]]
=== Exploración de objetos

Las búsquedas anteriores nos permiten encontrar determinada información textual en nuestra UH, es decir, explorar nuestros datos de una forma determinada. Otra forma de exploración que nos será muy práctica implica “navegar” por los objetos que hemos creado anteriormente.

Efectivamente, en las primeras fases de trabajo con nuestra UH podemos visualizar muy fácilmente el trabajo realizado, ya sea en el margen derecho de la pantalla, en el que visualizamos las citas, los códigos con los que están relacionadas, los hiperenlaces, etc., o también en los diferentes _administradores_ (de documentos, citas, códigos y anotaciones). Pero como hemos visto anteriormente, hay determinadas informaciones que no es posible visualizar de esta forma, como por ejemplo las relaciones entre códigos (aunque disponemos del _administrador_ __de relaciones__). También habíamos visto que la herramienta <<img-arbol-codigos>> es una ayuda para visualizar dichas relaciones. Una función similar nos ofrece el __Bosque de códigos__, al que podemos acceder mediante la opción `Códigos > Miscelánea > Bosque de códigos`. La única diferencia entre ambas es que mientras la primera nos muestra la estructura completa de los códigos existentes en la UH, la segunda nos muestra únicamente la del código seleccionado.

Por su parte, la herramienta __Explorador de UH__, a la que accedemos mediante el menú `Herramientas > Explorador de UH`, incluye, además de la estructura de códigos, el resto de elementos de la UH, desde documentos primarios hasta _Vistas de red_. Esta herramienta, por lo tanto, nos permite una visualización completa de nuestra UH, y en algunos momentos será imprescindible para no perdernos entre el conjunto de elementos y relaciones creados.

Aparte del diferente ámbito al que se aplican (un código, códigos y UH), no existen otras diferencias entre las tres herramientas, el funcionamiento de las mismas es similar, por lo que lo ilustraremos únicamente con el __Explorador de objetos__.

En la figura <<img-explorador-uh>> podemos observar cómo aparecen el conjunto de objetos de la UH (en los otros casos se mostrarían únicamente un código o el conjunto de códigos). A la izquierda de cada uno de ellos encontramos un signo `+` que permite desplegar la “rama” del objeto para mostrar sus relaciones. En el caso de los DPs, sus relaciones son las citas que incluyen, y para ellas los códigos con los que están relacionadas.

[[img-explorador-uh, Explorador de UH]]
.Explorador de UH
image::image-139.png[{alt="Explorador de UH", align="center"]

Si desplegamos la rama de códigos, la visualización será idéntica a la que podemos ver con el _Árbol de códigos_ o con el _Bosque de códigos._ En el caso de las familias, podemos ver sus miembros y, en el caso de haber creado _superfamilias_ podemos ver no sólo sus miembros sino también los operadores que han dado lugar a su creación. En el ejemplo siguiente podemos ver cómo la superfamilia _Derecha_ tiene como miembros los códigos “Anasagasti”, “Belda”, etc,.. y que en su creación se ha utilizado el operador lógico `OR`.

[[img-explorador-uh-familias, Explorador de UH: Familias de códigos]]
.Explorador de UH: Familias de códigos
image::image-140.png[{alt="Explorador de UH: Familias de códigos", align="center"]

Además de poder visualizar los diferentes objetos, podemos realizar acciones sobre los mismos, por ejemplo en la parte inferior de la ventana podemos editar o crear sus comentarios, mientras que si clicamos sobre un objeto con el botón derecho del ratón tendremos acceso a alguna de las acciones habituales sobre el mismo.

En la parte superior de la ventana encontramos también un menú que nos permite modificar algunas opciones de visualización, y unos iconos entre los que destaca el que permite seleccionar si queremos que la visualización de los objetos quede afectada o no por los filtros que se hayan aplicado previamente.

[[herramienta-de-consulta]]
=== Herramienta de consulta

Desde nuestro punto de vista, la herramienta más potente del programa es la __Herramienta de consulta__, la herramienta que nos permite realizar consultas sofisticadas de nuestros datos, que nos permite interrogar a nuestros datos para que nos muestre las citas que cumplen determinadas condiciones. Por lo tanto, con la _Consulta_ lo que obtendremos siempre será única y exclusivamente citas. Más concretamente las **citas que cumplen la condición de estar codificadas de una forma determinada**, lo que implica que esta herramienta está directamente relacionada con nuestro sistema de codificación y por lo tanto con el trabajo previo del analista. La _Consulta_ no nos ofrecerá ningún resultado, ninguna cita, que no haya sido previamente codificada.

Una posible consulta podría ser algo del tipo: “muéstrame todas las citas que están codificadas como... y al mismo tiempo como... O “muéstrame todas las citas que están codificadas como... pero no como...”.

En el apartado dedicado a la <<autocodificacion, autocodificación>> vimos cómo habíamos codificado las intervenciones de cada uno de los participantes y que posteriormente habíamos creado familias en las que agrupábamos a los participantes en función de su adscripción política. Tenemos por lo tanto una serie de códigos que podremos utilizar para realizar consultas en las que veamos las posibles diferencias en el discurso en función del partido político.

Nos podría interesar, por ejemplo, comparar las características de las respuestas evasivas del presidente Zapatero y del presidente Rajoy. Puesto que tenemos los códigos __Zapatero__, _RajoyPR_ y __Evasión__, podríamos realizar una consulta para solicitar las “citas codificadas como _Evasión_ y al mismo tiempo como __Zapatero__” y otra para solicitar las “citas codificadas como _Evasión_ y al mismo tiempo como __RajoyPR__”. Una vez que tenemos los resultados de ambas consultas (podríamos generar un informe impreso de cada una de ellas), podemos proceder a comparar las posibles similitudes y/o diferencias de ambos discursos.

Las consultas nos permitirán por lo tanto un nuevo nivel de análisis de nuestros datos y serán, entre otras cosas, una importante ayuda en nuestra tarea de “comparación constante”.

Una consulta consistirá siempre en la combinación de uno o más _operandos_ con un __operador__, donde los operandos son los códigos y familias de códigos y los operadores las condiciones que deben cumplirse para obtener un resultado. En el ejemplo anterior, para identificar las citas codificadas como _Zapatero_ y al mismo tiempo _Evasion,_ los operandos serían “Zapatero” y “Evasión” y el operador la condición Y.

[[la-pantalla-de-consulta]]
==== La pantalla de Consulta

Podemos acceder a la _Herramienta de consulta_ utilizando el icono “Prismático” de la barra de herramientas vertical o desde el menú `Análisis > Herramienta de consulta`. A continuación analizaremos la compleja ventana que nos aparece.

[[img-herramienta-consulta, Herramienta de consulta]]
.Herramienta de consulta
image::image-141.png[{alt="Herramienta de consulta", align="center"]

1) **Códigos y Familias de Códigos**footnote:[En el resto de esta sección nos referiremos a ellos como __operandos__.] existentes en la UH. Como decíamos, son los _Operandos_ que utilizaremos en la definición de la __consulta__. La activación de los operandos para su inclusión en la consulta se realiza haciendo clic dos veces sobre ellos,footnote:[Para la definición de la consulta no necesitamos escribir nada, todo el trabajo lo realizaremos haciendo clic sobre operandos y operadores.] lo que hará que en la ventana de resultados (5) aparezcan las citas relacionadas. Aunque en principio una consulta tiene que incluir operandos y operadores, simplemente seleccionando un operando veremos sus citas (si las tiene) en la zona de resultados. A medida que vayamos añadiendo más operandos y operadores, la zona de resultados cambiará para reflejar los cambios.

2) *Condiciones* a utilizar como operadores. Están agrupadas en tres categorías: Operadores __booleanos__, operadores _semánticos_ y operadores de __proximidad__. De nuevo, para seleccionar un operador sólo tenemos que hacer clic sobre el icono correspondiente.

3) Conjunto de las *expresiones* formuladas, es decir, conjunto de combinaciones de operandos y operadores. Cada línea visualizada en esta zona genera un resultado. Como podemos ver (figura <<herramienta-de-consulta>>), hemos realizado dos consultas, la primera para citas que cumplan la condición de estar codificadas como `Zapatero Y Evasión`, y la segunda para las codificadas como `RajoyLO Y Evasión`.

4) Esta zona es similar a la anterior, pero utiliza una _sintaxis_ diferente para visualizar las condiciones utilizadas. Como podemos ver, lo que se nos muestra es la *última consulta realizada*. Si en el paso anterior, tras las consultas ya realizadas hubiéramos clicado en el operador `O`, se nos mostraría el resultado de esa consulta:

`(“Zapatero” & “Evasion”) | (“RajoyLO” & “Evasion”)`

5) *Resultados*, citas que cumplen las condiciones de la última _consulta_ definida (la que se visualiza en (3)).

6) Posibilidad de seleccionar (para los operadores de distancia) la *distancia máxima* que debe separar a dos citas (y el tipo de unidad de media: párrafos...) para que sean incluidas en los resultados.

7) Acceso a la ventana <<img-herramienta-consulta-alcance, Alcance de consulta>>, para seleccionar los documentos a los que se aplicará la consulta. En este caso los operandos serán documentos y familias de documentos y los operadores sólo los booleanos.

[[img-herramienta-consulta-alcance, Herramienta de consulta: Alcance]]
.Herramienta de consulta: Alcance
image::image-142.png[{alt="Herramienta de consulta: Alcance", align="center"]

8) Convierte los resultados de la _consulta_ en un <<super-codigos, súper-código>>.

9) Conjunto de iconos que permiten eliminar una cita de la lista de resultados (no se borra la cita, sólo se la hace desaparecer de esta lista) o imprimir la lista de resultados.

10) Opciones de edición de las expresiones

C = Borra todas las expresiones introducidas previamente.

S = Invierte el orden de los dos últimos operandos.

P = Duplica el último operando introducido.

Recalc = Vuelve a calcular la _consulta_ después de hacer cambios en la selección de documentos o en la distancia.

Deshacer = Deshace la última acción.

Hacer de nuevo = Rehace la última acción.

[[sintaxis]]
==== Sintaxis

Probablemente una dificultad con la que nos encontraremos al crear la consulta tenga que ver con el hecho de que su definición se realiza utilizando la __Notación Polaca Inversa__.

[quote, Notación polaca inversa, 2015"]
____
La __Notación Polaca Inversa__, notación de postfijo, o notación posfija, (en inglés, __Reverse polish notation__, o RPN), es un método algebraico alternativo de introducción de datos. Su nombre viene por analogía con la relacionada notación polaca, una notación de prefijo introducida en 1920 por el matemático polaco Jan Lukasiewicz, en donde cada operador está antes de sus operandos. En la notación polaca inversa es al revés, primero están los operandos y después viene el operador que va a realizar los cálculos sobre ellos. Tanto la notación polaca como la notación polaca inversa no necesitan usar paréntesis para indicar el orden de las operaciones mientras la aridad del operador sea fija. cite:[npl2016]
____

Esto significa que, si habitualmente una suma la escribiríamos `4 + 5`, donde 4 y 5 son los operandos y el signo `+` es el operador, al utilizar la RPN tenemos que escribir en primer lugar los operandos y a continuación el operador, es decir, `4 5 +`.

Volviendo a nuesto ejemplo, en vez de Zapatero Y Evasion, tendríamos que escribir `Zapatero Evasion AND`.footnote:[Como comentábamos, en esta herramienta no escribimos, sino que clicamos, por lo que cuando en este apartado hagamos referencia a “escribir”, el significado real es realizar diversas combinaciones de clics sobre operandos y operadores.]

En el caso de que quisiéramos obtener como resultado todas las citas del código _Evasion_ en las intervenciones de cualquiera de los presidentes (Zapatero o Rajoy) tendríamos que añadir alguna condición más a nuestra consulta, por lo que tendríamos que formular la consulta de la siguiente forma:

----
Zapatero RajoyPR OR <1>

Evasion <2>

AND <3>
----

<1> en primer lugar realizamos una consulta para obtener las citas de cada uno de los presidentes (Zapatero o RajoyPR),
<2> la segunda consulta sería simplemente los resultados del código Evasion,
<3> finalmente combinaríamos ambos resultados con una condición `AND`.

Con una “sintaxis clásica” habríamos utilizado paréntesis para definir la prioridad de las operaciones. Pero como veíamos en la cita anterior, otra de las características de la RPN es que no utiliza paréntesis.

Aunque la formulación pueda parecer extraña, en la práctica es relativamente sencilla si tenemos en cuenta que cada vez que obtenemos un resultado en una consulta ese resultado pasa a convertirse en un operando (cada una de las líneas que aparecen en la zona 3 de la figura <<img-herramienta-consulta>> es un operando). Es decir, una vez que hemos obtenido las citas correspondientes a la primera parte de la consulta (1) éstas se convierten en un operando, lo mismo que las de (2), por lo que una vez que tenemos dos operandos los combinamos con el operador `AND` en (3).

[[img-esquema-consulta, Esquema consulta]]
.Esquema consulta
[mermaid, "consulta-01", png]
....
graph LR
 id1(Zapatero)
 id2(RajoyPR)
 id3(OR)
 id4(Zapatero OR RajoyPR)
 id5(Evasion)
 id6(AND)
 id7(Zapatero OR RajoyPR AND Evasion)
 id1 --- id3
 id2 --- id3
 id3 --> id4
 id4 --- id6
 id5 --- id6
 id6 --> id7
 classDef operador fill:#e5e5e5
 class id3,id6 operador
 classDef default fill: white, stroke: black, stroke-width:3px
 linkStyle default stroke: black, stroke-width:3px,fill:#ffffff
....

[[operadores]]
==== Operadores

Para ilustrar la sintaxis de la _Consulta_ hemos utilizado los operadores `AND` y `OR`, que junto a `XOR` y `NOT` forman parte de la categoría de operadores booleanos. Junto a estos, disponemos de otros dos conjuntos de operadores, los semánticos y los de proximidad. A continuación procederemos a explicar las características de cada uno de ellos.

[[operadores-booleanos]]
===== Operadores booleanos

En la siguiente tabla podemos ver la descripción de los operadores booleanos.

[[tab-operadores-booleanos, Operadores booleanos]]
.Operadores booleanos
[.center, cols="15%,15%,60%",options="header",]
|=======================================================================
|Operador |Sintaxis |Función
|OR |_A B_ OR |Selecciona las citas presentes en el operando A o en el
operando B footnote:[En esta explicación “citas presentes en el
operando...” significa “citas codificadas con el código o familia de
códigos...”]

|XOR |_A B_ XOR |Selecciona las citas presentes únicamente en A o en B
(Y no las citas comunes a A y B)

|AND |_A B_ AND |Selecciona las citas presentes en A y en B

|NOT |NOT _A_ |Selecciona las citas no presentes en A
|=======================================================================


A continuación utilizaremos diagramas de Venn para ilustrar gráficamente los resultados de cada uno de los operadores. En los diagramas, cada uno de los conjuntos (círculos) equivaldría a un operando (código o familia de códigos), y las zonas coloreadas serán el equivalente al resultado obtenido, es decir, a las citas que serían recuperadas. En la siguiente figura tenemos el primer ejemplo con los operadores booleanos.

[[img-diagrama-venn-booleanos, Diagrama de Venn: Operadores Booleanos]]
.Diagrama de Venn: Operadores Booleanos
image::image-144.png[{alt="Diagrama de Venn: Operadores Booleanos", align="center"]

En (1) tenemos el resultado de la aplicación del operador `OR`, que implica la selección de todas las citas que están codificadas como A o codificadas como B. Por lo tanto se trata de un operador inclusivo, El operador `XOR` (O exclusivo) selecciona igualmente las citas que están codificadas como A o como B pero no aquellas que están codificadas como A y al mismo tiempo como B, por lo que quedarían fuera las de la intersección de ambos conjuntos (2). En (3) vemos el operador más exclusivo, `AND`, puesto que en este caso sólo quedarán seleccionadas aquellas que están codificadas al mismo tiempo de una forma y de otra. En (4) tenemos el resultado de `A NOT`, es decir, todas aquellas citas que no están codificadas como A.

A continuación podemos ver la representación del ejemplo anterior en el que queríamos obtener “Todas las intervenciones del presidente Zapatero o del líder de la oposición Rajoy, que han sido codificadas como __Evasion__”,

[[img-diagrama-zapatero-1, Diagrama: (Zapatero OR Rajoy) AND Evasion]]
.Diagrama: (Zapatero OR Rajoy) AND Evasion
image::image-145.png[{alt="Diagrama: (Zapatero OR Rajoy) AND Evasion", align="center"]

Imaginemos ahora una situación como la representada en la siguiente figura, en la que el diagrama de Venn representa cuatro códigos que incluyen un total de catorce citas distribuidas de la siguiente forma:

[[img-diagrama-ejemplo, Diagrama de Venn: Ejemplo de codificación]]
.Diagrama de Venn: Ejemplo de codificación
image::image-146.png[{alt="Diagrama de Venn: Ejemplo de codificación", align="center"]

Ahora podemos ver fácilmente el resultado (citas) de diferentes consultas

[[tab-escritura-consulta-multiple, Escritura consulta múltiple]]
.Escritura consulta múltiple
[.center, cols="45%,25%,30%",options="header, autowidth",]
|=======================================================================
|Queremos obtener... |Sentencia |Resultado
|Citas codificadas como A o como B |Código-A  Código-B  OR |C1, C2, C3,
C4, C5, C6, C7, C8, C9

|Citas codificadas como A o como B pero no como A y B |Código-A Código-B
XOR |C1, C2, C3, C6, C7, C8, C9

|Citas codificadas como A y como B |Código-A Código-B Y |C4, C5

|Citas no codificadas como C |Código-C NOT |C1, C2, C5, C6, C7, C13, C14
|=======================================================================

Podemos ir “apilando” los resultados de las consultas para definir otras más complejas. Imaginemos por ejemplo que nos interesa obtener las citas que están codificadas con el Código-A o con el Código-B pero no con el Código-C. El resultado debería ser el que vemos en el diagrama de Venn de la figura .

[[img-diagrama-consulta-multiple, Diagrama de Venn: Consulta múltiple]]
.Diagrama de Venn: Consulta múltiple
image::image-147.png[{alt="Diagrama de Venn: Consulta múltiple", align="center"]

Y la forma de realizarla sería como vemos en la siguiente figura.

[[img-consulta-multiple, Consulta múltiple]]
.Consulta múltiple
[mermaid, "consulta-02", png]
....
graph LR
id1(Código-A)
id2(Código-B)
id3(OR)
id4(Código-C)
id5(NOT)
id6(Código-A OR Código-B)
id7(Código-C NOT)
id8(AND)
id9(Código-A OR Código-B<br/>AND NOT Código-C)
id1 --- id3
id2 --- id3
id3 --> id6
id4 --- id5
id5 --> id7
id6 --- id8
id7 --- id8
id8 --> id9
classDef operador fill:#e5e5e5
class id3,id5,id8 operador
classDef default fill: white, stroke: black, stroke-width:3px
linkStyle default stroke: black, stroke-width:3px,fill:#ffffff
....


[[operadores-semanticos]]
===== Operadores Semánticos

Como hemos visto, las _consultas_ con operadores booleanos, sólo requieren de la existencia de códigos. En el caso de los operadores semánticos necesitamos además haber creado previamente relaciones entre códigos. Más concretamente, los operadores semánticos se basan en la existencia de relaciones de tipo transitivo entre códigos.footnote:[En las relaciones predefinidas: “Is part of”, “Is cause of” y “Is a”.]

[[tab-operadores-semanticos, Operadores semánticos]]
.Operadores semánticos
[.center, cols="15%,85%",options="header",]
|=======================================================================
|Operador |Función
|Down |Selecciona las citas relacionadas con el código y con cualquiera
de sus subtérminos, (descendientes)  es decir, aquellos otros códigos
con los que se ha establecido una relación

|Up |Recupera las citas relacionadas con el código y sus superiores
directos (sólo un nivel)

|Siblings |Recupera las citas relacionadas con el código, con sus
descendientes directos (hijos) y los subtérminos directos de un código
superior (hijos). No recupera las relacionadas con el nivel superior
(padre)
|=======================================================================

Como también comentábamos, ATLAS.ti, a diferencia de otros programas, no permite crear jerarquías de códigos, pero sí nos permite crear estructuras de codificación gracias a la creación de relaciones entre códigos. Anteriormente habíamos creado (a través de la definición de relaciones del tipo `is a` y de `is cause of`) una jerarquía de códigos para reproducir la clasificación de tipos de respuestas de citenp:[rasiah2010]. Si disponemos de esta estructura definida previa a la asignación de citas a códigos, nuestra estrategia de codificación implicará codificar única y exclusivamente los códigos del nivel inferior en la jerarquía: __Ans Direct__, __Ans Indirect__, __Ev Full__, __Ev Substantial__, etc. El resto de códigos en la estructura (__Answer__, __Evasion__...) serán códigos libres, sin citas asociadas, pero aún así podremos, con la utilización de los operadores semánticos, obtener el conjunto de citas relacionadas con cualquiera de los códigos que se encuentran en niveles superiores de la estructura. Si _Ans Direct_ tiene 6 citas y _Ans Indirect_ tiene 9 citas, dado que ambas son un tipo de __Answer__, aunque este código tenga cero citas parece lógico pensar que en realidad tenemos 15 citas relacionadas con __Answer__. Igualmente, si sumamos el conjunto de citas de los códigos vinculados con __Evasion__, aunque _Evasion_ tiene cero citas, en realidad tenemos 93 citas con modalidades de evasión.

Para obtener esos resultados utilizaremos el operador `DOWN`, por lo tanto:

Todas las citas por debajo de Answer: `Answer DOWN`

Todas las citas por debajo de Evasion: `Evasion DOWN`

En la figura podemos ver la _vista de red_ de los códigos `Answer DOWN`. Dado que _Ans Direct_ tiene 6 citas y _Ans Indirect_ tiene 9, el resultado de `Answer DOWN` será de 15 citas (si no hay ninguna que esté en ambos códigos).

[[img-red-answer, Red _Answer_]]
.Red _Answer_
image::image-148b.png[{alt="Red _Answer_", align="center"]

Por supuesto, podemos combinar los operadores semánticos con los otros tipos de operadores (booleanos y de proximidad). En un ejemplo anterior construíamos una consulta para identificar todas las citas de intervenciones de los presidentes Zapatero y Rajoy codificadas como Evasion.

(1) `Zapatero Evasion AND`

(2) `RajoyPR Evasion AND`

(3) `OR`


Pero dado que nuestro código _Evasion_ en realidad es un código libre, el resultado de esa consulta será de cero citas. Como hemos visto, tendremos que realizarla de nuevo incluyendo el operador DOWN

// Forma original, demasiado complicada
////
(1) `Zapatero`

(2) `Evasion DOWN`

(3) `AND`

(4) `RajoyLO`

(5) `Evasion DOWN`

(6) `AND`

(7) `OR`
////

[[consulta-combinada, Consulta combinando tipos de operadores]]
.Consulta combinando tipos de operadores
----
Zapatero RajoyPR OR <1>

Evasion DOWN <2>

AND <3>
----

Aunque parezca una consulta muy compleja en realidad es simple, puesto que

<1> recuperamos todas las citas codificadas como Zapatero o como RajoyPR,
<2> recuperamos todas las citas codificadas con códigos "por debajo de" Evasion, y
<3> añadimos el operador AND para que el resultado sea

//

 todas las intervenciones de Zapatero o Rajoy (presidente) codificadas con alguna modalidad de Evasion

[[img-esquema-consulta-combinada, Consulta combinando tipos de operadores]]
.Consulta combinando tipos de operadores
[mermaid, "consulta-03", png]
....
graph LR
id1(Zapatero)
id2(RajoyPR)
id3(OR)
id4(Zapatero OR RajoyPR)
id5(Evasion)
id6(DOWN)
id7(Evasion DOWN)
id8(AND)
id9(Zapatero OR RajoyPR <br/>AND Evasion DOWN)
id1 --- id3
id2 --- id3
id3 --> id4
id5 --- id6
id6 --> id7
id4 --- id8
id7 --- id8
id8 --> id9
classDef operador fill:#e5e5e5
class id3,id6,id8 operador
classDef default fill: white, stroke: black, stroke-width:3px
linkStyle default stroke: black, stroke-width:3px,fill:#ffffff
....

// Forma original, demasiado complicada
////
[mermaid, "image-147b", png]
....
graph LR
id1(Zapatero)
id2(Evasión)
id3(DOWN)
id4(Evasion DOWN)
id5(AND)
id6(Zapatero AND Evasion DOWN)
id7(RajoyLO)
id8(Evasión)
id9(DOWN)
id10(Evasion DOWN)
id11(AND)
id12(RajoyLO AND Evasion DOWN)
id13(OR)
id14(Zapatero AND Evasion DOWN<br/>OR<br/>RajoyLO AND Evasion DOWN)
id1 --- id5
id2 --- id3
id3 --> id4
id4 --- id5
id5 --> id6
id7 --- id11
id8 --- id9
id9 --> id10
id10 --- id11
id11 --> id12
id6 --- id13
id12 --- id13
id13 --> id14
....
////

[[operadores-de-proximidad]]
===== Operadores de Proximidad

Por último, los operadores de proximidad, como su nombre indica, permiten recuperar citas en función de la relación espacial existente entre diferentes códigos.

//Comprobar [juan]

[[tab-operadores-proximidad, Operadores de proximidad]]
.Operadores de proximidad
[.center, .center, cols="15%,85%",options="header, autowidth",]
|=======================================================================
|Operador |Función
|Within |La cita codificada como Código-D está Within la cita codificada
como Código-B: `Código-D Código-B Within`

|Encloses |La cita codificada como Código-B encloses la cita codificada
como Código-D: `Código-B Código-D Within`

|Overlapped by |La cita codificada como Código-A está overlapped by la
cita codificada como Código-C: `Código-A Código-C overlapped by`

| |La cita codificada como Código-C está overlapped by la cita
codificada como Código-B Código-C: `Código-B overlapped by`

|Overlapps |La cita codificada como Código-C overlaps la cita codificada
como Código-A `Código-C Código-A overlaps`

| |La cita codificada como Código-B overlaps la cita codificada como
Código-C: `Código-B Código-C overlaps`

|Follows |La cita codificada como Código-B follows la cita codificada
como Código-A: `Código-B Código-A follows`

|Precedes |La cita codificada como Código-A precedes la cita codificada
como Código-B: `Código-A Código-B precedes`

|Cooccur |Todos los casos en los que hay algún tipo de “contacto” entre
citas
|=======================================================================


En la figura hemos simulado una hipotética codificación que nos permitirá ilustrar cómo funcionan estos operadores.

[[img-ilustracion-operadores-proximidad, Operadores de proximidad]]
.Operadores de proximidad
image::image-149.png[{alt="Operadores de proximidad", align="center"]

Como vemos, el operador `Cooccur` es una combinación de varios de los operadores de proximidad (todos menos _Follows_ y _Precedes_), por lo que en muchas ocasiones podremos utilizarlo en vez de alguno de los otros. Además, probablemente sea conveniente su utilización en vez del operador booleano _AND_. Efectivamente, el operador _AND_ es altamente selectivo, puesto que implica que `Código-A Código-B AND` sólo obtendrá resultados cuando una cita está vinculada con ambos códigos.

Volviendo una vez más a nuestro ejemplo, en la figura <<img-concurrencia-citas>> podemos ver cómo en un mismo párrafo tenemos una cita (barra gris) codificada como _Zapatero_ (resultado de la autocodificación original) y otra cita (resaltada) codificada como __Ev Medium__, se trata por lo tanto de una intervención del presidente Zapatero que hemos codificado como respuesta evasiva. Sin embargo, en una consulta como la que habíamos realizado previamente, utilizando el operador AND no aparecería esta cita, puesto que la cita codificada como _Ev Medium_ no está codificada al mismo tiempo como __Zapatero__. Por lo tanto, para poder recuperar citas que tengan estas características debemos utilizar el operador _Cooccur_ (aunque en este ejemplo también funcionaría __Within__).

[[img-concurrencia-citas, Concurrencia de citas]]
.Concurrencia de citas
// en html cambio tamaño imagen, en pdf se mantiene original
ifdef::backend-html5[]
image::image-150.png[{alt="Concurrencia de citas", width=75%, align="center"]
endif::[]
ifdef::backend-pdf[]
image::image-150.png[{alt="Concurrencia de citas", align="center"]
endif::[]

Por lo tanto, nuestra consulta debería ser.

(1) `Evasion DOWN`

(2) `Zapatero`

(3) `Cooccur`

Para finalizar con esta sección de operadores de proximidad, pondremos otro ejemplo para ilustrar los operadores _Follows_ y __Precedes__. Estos operadores nos permitirán contestar a la pregunta ¿en qué ocasiones se ha hecho referencia al tema X a continuación (o antes de) el tema Y? Es decir, ¿qué citas hemos codificado como X a continuación de citas codificadas como Y?

En el modelo de citenp:[rasiah2010] que hemos utilizado para codificar las respuestas evasivas, estas, al igual que las respuestas (__Answer__) y las respuestas intermedias (__A Intermediate__) podían ser consecuencia de tres modalidades de pregunta (__Q Y/N__, _Q Wh_ y __Q Disjunctive__). Nos puede interesar, por lo tanto, identificar citas codificadas como _Evasion_ que aparecen única y exclusivamente a continuación de citas codificadas como _Q Y/N_ (preguntas de tipo Sí/No). En ese caso la consulta anterior quedaría de la siguiente forma:

----
Evasion DOWN <1>

Zapatero <2>

Cooccur <3>

Q Y/N <4>

Follows <5>
----

<1> Recupera las citas de todos los códigos "por debajo" de Evasion.
<2> Recupera todas las citas codificadas como Zapatero.
<3> Coocurrencia de <1> y <2>.
<4> Recupera todas las citas codificadas como Q Y/N.
<5> Recupera las citas en las que <4> FOLLOWS A <3>.

[[operador-follows, Operador _Follows_]]
.Operador _Follows_
[mermaid, "consulta-04", png]
....
graph LR
id1(Evasion)
id2(DOWN)
id3(Evasion DOWN)
id4(Zapatero)
id5(COOCCUR)
id6(Evasion DOWN<br/>COOCCUR<br/>Zapatero)
id7(Q Y/N)
id8(FOLLOWS)
id9(Evasion DOWN COOCCUR Zapatero<br/>FOLLOWS<br/>Q Y/N)
id1 --- id2
id2 --> id3
id3 --- id5
id4 --- id5
id5 --> id6
id6 --- id8
id7 --- id8
id8 --> id9
classDef operador fill:#e5e5e5
class id2,id5,id8 operador
classDef default fill: white, stroke: black, stroke-width:3px
linkStyle default stroke: black, stroke-width:3px,fill:#ffffff
....


[[super-codigos]]
==== Super Códigos

En el apartado dedicado a las familias veíamos la posibilidad de crear un nuevo objeto, las _superfamilias_ (de documentos, códigos o memos) utilizando un editor de consultas simplificado con respecto al que estamos viendo en esta sección. Ahora, a partir de las consultas que venimos realizando, podemos crear un nuevo objeto, los __supercódigos__, haciendo clic en el icono __Super-códgio__. La característica peculiar de estos códigos es que su contenido (citas) será el resultado dinámico de la consulta a partir de la que se hayan construido y que por lo tanto son la forma práctica de “guardar” consultas (no existe ninguna otra, si queremos guardar una consulta tenemos que crear un __supercódigo__). El significado de “resultado dinámico” es que, en tanto que son una consulta guardada, cualquier cambio en la UH que afecte a la consulta quedará registrado en el __supercódigo__. Es decir, imaginemos que nuestro código _Ans Direct_ incluye 12 citas y nuestro código _Ans Indirect_ 14 citas; la consulta `Answer SUB` nos dará un resultado de 26 citas, por lo que si creamos un _supercódigo_ a partir de esta consulta este contendrá las mismas 26 citas. Si posteriormente a la creación del _supercódigo_ añadimos dos citas más al código __Ans Direct__, el _supercódigo_ las incorporará automáticamente.

TIP: Podemos crear una “vista fija” de un supercódigo con la opción `Códigos > Miscelánea > Crear instantánea`, que creará un nuevo código con la misma etiqueta a la que añadirá `[SN 1]` y que mantendrá fijo el número de citas que tenía el supercódigo en el momento de la creación.de este nuevo código.

Teóricamente es posible modificar las características de un __supercódigo__, es decir, modificar la consulta a partir de la que se ha creado, por ejemplo, en el caso anterior, podríamos decidir añadir un nuevo tipo de _Answer_ creando un código __Ans Intermediate__, por lo que la consulta `Answer SUB` debería incluirlo también. Para ello podríamos utilizar la opción `Códigos > Miscelánea > Editar consulta`, aunque dada la complejidad de la sintaxis de edición prácticamente es preferible volver a crear el _supercódigo_ desde el inicio (rehaciendo la __consulta__). Una prueba de dicha dificultad es que, por ejemplo, la _consulta_ Evasion SUB queda representada, en el editor de consultas como `d(c(Evasion!))`.

Por lo demás, se trata de códigos con las mismas características que el resto, es decir, pueden relacionarse con otros códigos y con anotaciones y pueden incluirse en las vistas de red, aunque no podemos incluir citas en ellas siguiendo el procedimiento habitual.

TIP: Para consultas simples en las que únicamente queremos combinar códigos utilizando el operador OR (`Código-A Código-B OR`) no es necesario utilizar la __Herramienta de consulta__. Podemos hacerlo directamente desde el administrador (o el menú) de códigos seleccionando varios códigos y eligiendo la opción `Miscelánea > Crear super código.`

[[seleccion-de-documentos]]
==== Selección de documentos

Si utilizamos la _consulta_ tal y como la hemos descrito, ésta dará como resultado las citas, que cumplan las condiciones especificadas en toda la UH. Pero nos puede interesar que el resultado haga referencia sólo a determinados DPs. Podemos utilizar esta opción, por ejemplo, si nos interesa obtener las citas relacionadas con un código determinado, pero sólo en los DPs que hemos agrupado en la _familia_ _Legisltura IX._

Para la selección de documentos, en la ventana de la _Herramienta de consulta_ haremos clic en el botón __Alcance__, lo que nos abrirá una nueva ventana similar a la principal de consultas. En este caso los operandos son tanto los documentos como las familias de documentos y los operadores únicamente los booleanos.

[[img-consultas-alcance, Consultas: alcance]]
.Consultas: alcance
image::image-153.png[{alt="Consultas: alcance", align="center"]

WARNING: Si creamos un supercódigo a partir de una _Consulta_ en la que hemos realizado una selección de documentos, esta selección no afectará al supercódigo, que incluirá las citas que cumplan la condición especificada en el conjunto de DPs de la UH.

[[otras-opciones]]
==== Otras opciones

Otras posibilidades que nos ofrece la herramienta es obtener información adicional sobre los objetos que aparecen en ella: familias, códigos y citas (los resultados de la consulta). Podemos acceder a esas informaciones desde el menú contextual (haciendo clic con el botón derecho del ratón) sobre alguno de esos elementos.

En la figura podemos ver las informaciones disponibles para códigos, citas y familias de códigos.

[[img-informacion-elementos-consulta, Información sobre elementos de consulta]]
.Información sobre elementos de consulta
image::image-154.png[{alt="Información sobre elementos de consulta", align="center"]

[[concurrencias]]
=== Concurrencias

Anteriormente hemos ilustrado el concepto de __concurrencia__, y hemos visto que podemos realizar consultas utilizando el operador _cooccur_ para recuperar citas que cumplan la condición de estar codificadas de forma coocurrente con varios códigos. En esta sección veremos dos herramientas adicionales que permiten seguir explorando las concurrencias.

[[arbol-de-concurrencias]]
==== Árbol de concurrencias

El árbol de concurrencias es una herramienta similar a los otros “árboles” que hemos visto en el apartado _Exploración de objetos_, pues nos muestra una estructura jerarquizada de objetos que podemos ir desplegando para llegar hasta cierto nivel de detalle. Las dos ramas principales de objetos son los códigos y los documentos primarios . En el caso de los códigos (izquierda en la figura <<img-explorador-concurrencias>>) visualizamos el conjunto de códigos de la UH y, en aquellos casos en que se produce concurrencias podemos desplegar la rama del código para visualizar con qué códigos se produce dicha concurrencia y finalmente en qué citas concretas. En el caso de los DPs, la expansión de la rama de documento nos mostrará una visualización idéntica a la anterior, con la única diferencia de que en este caso no visualizamos los códigos del conjunto de la UH, sino únicamente aquellos en los que se producen concurrencias para el documento seleccionado (derecha en la figura).

[[img-explorador-concurrencias, Explorador de concurrencias]]
.Explorador de concurrencias
image::image-158.png[{alt="Explorador de concurrencias", align="center"]

[[tabla-de-concurrencias]]
==== Tabla de concurrencias

La otra herramienta que nos ofrece información sobre las concurrencias es la <<img-tabla-concurrencias>>, que nos permite visualizar de una forma mucho más eficaz los casos de códigos que tienen concurrencias de citas, puesto que nos permite literalmente construir una tabla de doble entrada donde las filas y las columnas son códigos y las celdas nos informan de la cantidad de citas que coocurren en esos códigos.

En la figura, en (1) y (2) se nos muestran el conjunto de códigos de la UH, para que podamos seleccionar aquellos que queremos incluir en la tabla como columnas (1) y como filas. En este caso la zona de códigos de filas está vacía puesto que los hemos incluído todos en nuestra tabla. En (3) y (4) aparecen los códigos que hemos seleccionado para columnas y filas. Como podemos ver, hemos seleccionado en columnas los códigos que hacen referencia a Zapatero y a Rajoy (tanto líder de la oposición como presidente), puesto que queremos tener una “visión panorámica” de las coocurrencias que se producen entre ellos. Por ese motivo, hemos incluido como filas la totalidad de códigos de la UH. El resultado, la tabla, aparece en (5). Finalmente, en (6) y (7), al seleccionar alguna de las celdas, aparecen las citas que coocurren.

[[img-tabla-concurrencias, Tabla de Concurrencias]]
.Tabla de Concurrencias
// en html cambio tamaño imagen, en pdf se mantiene original
ifdef::backend-html5[]
image::image-159.png[{alt="Tabla de Concurrencias", width=75%, align="center"]
endif::[]
ifdef::backend-pdf[]
image::image-159.png[{alt="Tabla de Concurrencias", align="center"]
endif::[]


[[analizador-de-codificaciones]]
=== Analizador de codificaciones

Otra herramienta que puede ser interesante en algunas fases del análisis es el __Analizador de codificaciones__, que nos informará de si existen codificaciones redundantes, es decir, códigos que han sido relacionados con citas muy similares, entre las que hay sólo una ligera diferencia. El _analizador_ nos informará de ello y dejará al analista la decisión de qué hacer en esos casos.

En la figura <<img-ejemplo-codificacion-redundante>> podemos ver un hipotético ejemplo de codificación redundante. Tenemos un mismo párrafo con tres citas muy similares. Entre la primera y la segunda la diferencia es que la primera incluye algo más de texto. Entre la segunda y la tercera, la única diferencia es que en un caso se ha incluido la identificación de hablante (__Presidente.-__) y en el otro no. En este caso todas las citas han sido codificadas con el mismo código __Economía__.

[[img-ejemplo-codificacion-redundante, Ejemplo de codificación redundante]]
.Ejemplo de codificación redundante
// en html cambio tamaño imagen, en pdf se mantiene original
ifdef::backend-html5[]
image::image-160.png[{alt="Ejemplo de codificación redundante", width=75%, align="center"]
endif::[]
ifdef::backend-pdf[]
image::image-160.png[{alt="Ejemplo de codificación redundante", align="center"]
endif::[]


Al utilizar el __Analizador de codificación redundante__, aparecerá una ventana como la de la siguiente figura, en la que podemos ver (1) los códigos que según el programa podrían incluir citas redundantes. Si seleccionamos uno de esos códigos, en (2) y (3) se nos mostrarán las parejas de citas que podrían ser redundantes. Podemos entonces decidir si queremos _eliminar_ o _desvincular_ la cita en (2) o en (3) o si queremos _fusionar_ ambas citas.

[[img-analizador-codificacion-redundante, Analizador de codificación redundante]]
.Analizador de codificación redundante
image::image-161.png[{alt="Analizador de codificación redundante", align="center"]
